--- a/src/brokers/kis_broker.py
+++ b/src/brokers/kis_broker.py
@@ -49,6 +49,10 @@
             "ws://ops.koreainvestment.com:21000" if self.env == "prod" else "ws://ops.koreainvestment.com:31000",
 
         )
 
         self.token_cache_path = self.settings["kis"].get("token_cache_path", TOKEN_CACHE_DEFAULT)
 
+        # hashkey (optional; recommended for POST trading endpoints)
 
+        self.use_hashkey = bool(self.settings["kis"].get("use_hashkey", False))
 
+        self.hashkey_cache_ttl_sec = float(self.settings["kis"].get("hashkey_cache_ttl_sec", 30))
 
+        self._hashkey_cache: Dict[str, Any] = {"key": None, "value": None, "ts": 0.0}
 
         os.makedirs(os.path.dirname(self.token_cache_path), exist_ok=True)
 
         self.session = requests.Session()
 
         self._token: Optional[str] = None
 
@@ -121,6 +125,41 @@
         return key
 
 
 
     # --------------- Base request ---------------
 
+
 
+    def get_hashkey(self, body: Dict[str, Any]) -> Optional[str]:
 
+        """Return hashkey for POST body (optional).
 
+        Per KIS docs, hashkey is not mandatory for POST calls, but recommended for integrity.
 
+        """
 
+        if not self.use_hashkey:
 
+            return None
 
+        try:
 
+            body_key = json.dumps(body, ensure_ascii=False, separators=(",", ":"), sort_keys=True)
 
+        except Exception:
 
+            body_key = str(body)
 
+
 
+        now = time.time()
 
+        ck = self._hashkey_cache
 
+        if ck.get("key") == body_key and (now - float(ck.get("ts", 0.0))) <= self.hashkey_cache_ttl_sec:
 
+            return ck.get("value")
 
+
 
+        url = f"{self.base_url}/uapi/hashkey"
 
+        headers = {
 
+            "content-type": "application/json; charset=utf-8",
 
+            "appkey": self.app_key,
 
+            "appsecret": self.app_secret,
 
+        }
 
+        try:
 
+            resp = self.session.post(url, headers=headers, json=body, timeout=(self.timeout_connect, self.timeout_read))
 
+            resp.raise_for_status()
 
+            data = resp.json() if resp.content else {}
 
+            hashv = data.get("HASH") or data.get("hash") or (data.get("output") or {}).get("HASH")
 
+            if hashv:
 
+                self._hashkey_cache = {"key": body_key, "value": hashv, "ts": now}
 
+            return hashv
 
+        except Exception as e:
 
+            logging.warning("hashkey fetch failed: %s", e)
 
+            return None
 
+
 
     def request(
 
         self,
 
         tr_id: str,
 
@@ -151,6 +190,12 @@
             if self.custtype:
 
                 headers["custtype"] = self.custtype
 
 
 
+            # Optional hashkey header for POST requests
 
+            if method != "GET" and json_body is not None:
 
+                hk = self.get_hashkey(json_body)
 
+                if hk:
 
+                    headers["hashkey"] = hk
 
+
 
             try:
 
                 time.sleep(self.rate_limit_sleep)
 
                 timeout = (self.timeout_connect, self.timeout_read)
 
@@ -210,7 +255,7 @@
     def send_order(self, code: str, side: str, qty: int, price: Optional[float] = None, ord_dvsn: str = "01") -> Dict[str, Any]:
 
         # side: BUY/SELL
 
         url = f"{self.base_url}/uapi/domestic-stock/v1/trading/order-cash"
 
-        tr_id = self._tr_id("VTTC0802U", "TTTC0802U") if side.upper() == "BUY" else self._tr_id("VTTC0801U", "TTTC0801U")
 
+        tr_id = self._tr_id("VTTC0012U", "TTTC0012U") if side.upper() == "BUY" else self._tr_id("VTTC0011U", "TTTC0011U")
 
         body = {
 
             "CANO": self.account_no,
 
             "ACNT_PRDT_CD": self.account_product,
 
@@ -224,7 +269,7 @@
 
 
     def cancel_order(self, code: str, qty: int, orgn_odno: str, ord_orgno: str, ord_dvsn: str = "01") -> Dict[str, Any]:
 
         url = f"{self.base_url}/uapi/domestic-stock/v1/trading/order-rvsecncl"
 
-        tr_id = self._tr_id("VTTC0803U", "TTTC0803U")
 
+        tr_id = self._tr_id("VTTC0013U", "TTTC0013U")
 
         body = {
 
             "CANO": self.account_no,
 
             "ACNT_PRDT_CD": self.account_product,
 
@@ -240,7 +285,7 @@
 
 
     def get_orders(self, start_date: str, end_date: str) -> Dict[str, Any]:
 
         url = f"{self.base_url}/uapi/domestic-stock/v1/trading/inquire-daily-ccld"
 
-        tr_id = self._tr_id("VTTC8001R", "TTTC8001R")
 
+        tr_id = self._tr_id("VTTC0081R", "TTTC0081R")
 
         params = {
 
             "CANO": self.account_no,
 
             "ACNT_PRDT_CD": self.account_product,
 
--- a/src/analyzer/backtest_runner.py
+++ b/src/analyzer/backtest_runner.py
@@ -26,20 +26,32 @@
     stop_loss: float
 
     max_holding_days: int
 
     max_positions: int
 
+    trend_ma25_rising: bool
 
+    selection_horizon_days: int
 
+
 
 
 
 
 
 def load_strategy(settings: Dict) -> StrategyParams:
 
     strat_file = Path("config/strategy.yaml")
 
     strat = load_yaml(strat_file) if strat_file.exists() else settings.get("strategy", {})
 
+
 
+    buy_cfg = strat.get("buy", {}) or {}
 
+    sell_cfg = strat.get("sell", {}) or {}
 
+    pos_cfg = strat.get("position", {}) or {}
 
+    trend_cfg = (buy_cfg.get("trend_filter", {}) or {})
 
+    report_cfg = strat.get("report", {}) or {}
 
+
 
     return StrategyParams(
 
         liquidity_rank=int(strat.get("liquidity_rank", 300)),
 
         min_amount=float(strat.get("min_amount", 5e10)),
 
-        buy_kospi=float(strat.get("buy", {}).get("kospi_disparity", strat.get("disparity_buy_kospi", -0.05))),
 
-        buy_kosdaq=float(strat.get("buy", {}).get("kosdaq_disparity", strat.get("disparity_buy_kosdaq", -0.10))),
 
-        sell_disparity=float(strat.get("sell", {}).get("take_profit_disparity", strat.get("disparity_sell", -0.01))),
 
-        stop_loss=float(strat.get("sell", {}).get("stop_loss", strat.get("stop_loss", -0.05))),
 
-        max_holding_days=int(strat.get("sell", {}).get("max_holding_days", strat.get("max_holding_days", 3))),
 
-        max_positions=int(strat.get("position", {}).get("max_positions", strat.get("max_positions", 10))),
 
+        buy_kospi=float(buy_cfg.get("kospi_disparity", strat.get("disparity_buy_kospi", -0.05))),
 
+        buy_kosdaq=float(buy_cfg.get("kosdaq_disparity", strat.get("disparity_buy_kosdaq", -0.10))),
 
+        sell_disparity=float(sell_cfg.get("take_profit_disparity", strat.get("disparity_sell", -0.01))),
 
+        stop_loss=float(sell_cfg.get("stop_loss", strat.get("stop_loss", -0.05))),
 
+        max_holding_days=int(sell_cfg.get("max_holding_days", strat.get("max_holding_days", 3))),
 
+        max_positions=int(pos_cfg.get("max_positions", strat.get("max_positions", 10))),
 
+        trend_ma25_rising=bool(trend_cfg.get("ma25_rising", strat.get("trend_ma25_rising", False))),
 
+        selection_horizon_days=int(report_cfg.get("selection_horizon_days", 1)),
 
     )
 
 
 
 
 
@@ -51,120 +63,225 @@
     return merged.head(params.liquidity_rank)["code"].tolist()
 
 
 
 
 
+
 
 def run_backtest(store: SQLiteStore, params: StrategyParams, output_dir: Path = Path("data")):
 
+    """Next-Open 백테스트.
 
+
 
+    - 신호 생성: t일 종가 기준(당일 데이터로) 매수 신호 생성
 
+    - 진입 체결: t+1일 시가
 
+    - 청산 체결: t+1일 시가 (t일 종료 시점에 청산 조건 충족 시)
 
+    - 종목 선별(신호) 지표와, 실제 매매(트레이드) 승률을 분리해서 리포트로 저장
 
+      * selection_report.csv: '선별된 종목'의 다음날 성과(기본: 익일 시가->종가)
 
+      * trade_log.csv: 실제 진입/청산이 발생한 트레이드 로그
 
+    """
 
     prices = store.load_all_prices()
 
     if prices.empty:
 
         raise SystemExit("daily_price 가 비어있습니다. 먼저 데이터를 적재하세요.")
 
+
 
     stock_info = pd.read_sql_query("SELECT * FROM stock_info", store.conn)
 
-    universe = select_universe(prices, stock_info, params)
 
-    prices = prices[prices["code"].isin(universe)].copy()
 
+    stock_info = stock_info[["code", "market"]].copy()
 
+    market_map = dict(zip(stock_info["code"], stock_info["market"]))
 
+
 
     prices["date"] = pd.to_datetime(prices["date"])
 
-    prices = prices.sort_values(["code", "date"])
 
-
 
+    prices = prices.sort_values(["code", "date"]).copy()
 
+    # trend filter용 (ma25 상승)
 
+    prices["ma25_prev"] = prices.groupby("code")["ma25"].shift(1)
 
+
 
+    # 날짜 리스트
 
     dates = sorted(prices["date"].unique())
 
     if len(dates) < 2:
 
         raise SystemExit("가격 데이터가 부족합니다.")
 
 
 
     cash = float(getattr(params, "initial_cash", 10_000_000) or 10_000_000)
 
     equity_curve: List[Dict] = []
 
-    trade_log: List[Dict] = []
 
+    trades: List[Dict] = []
 
+    selection_rows: List[Dict] = []
 
     positions: Dict[str, Dict] = {}
 
 
 
+    # 날짜별 슬라이스 접근을 빠르게 하기 위해 groupby 결과를 dict로
 
     grouped = {code: df.reset_index(drop=True) for code, df in prices.groupby("code")}
 
 
 
+    def has_rows(code: str, d: pd.Timestamp) -> bool:
 
+        dfc = grouped.get(code)
 
+        if dfc is None:
 
+            return False
 
+        # dfc["date"]는 정렬된 상태. equality filter는 느릴 수 있으나 데이터 규모에서 충분.
 
+        return (dfc["date"] == d).any()
 
+
 
+    def get_row(code: str, d: pd.Timestamp):
 
+        dfc = grouped[code]
 
+        row = dfc.loc[dfc["date"] == d]
 
+        if row.empty:
 
+            return None
 
+        return row.iloc[0]
 
+
 
+    def buy_threshold(code: str) -> float:
 
+        market = market_map.get(code, "KOSPI") or "KOSPI"
 
+        return params.buy_kospi if "KOSPI" in market else params.buy_kosdaq
 
+
 
+    # 본 루프: i는 today index, i+1은 next (체결가로 사용)
 
     for i in range(len(dates) - 1):
 
-        today_dt = dates[i]
 
-        next_dt = dates[i + 1]
 
-        today_date = today_dt.date()
 
-
 
-        for code, dfc in grouped.items():
 
-            row_today = dfc[dfc["date"] == today_dt]
 
-            row_next = dfc[dfc["date"] == next_dt]
 
-            if row_today.empty or row_next.empty:
 
-                continue
 
-
 
-            today = row_today.iloc[0]
 
-            next_row = row_next.iloc[0]
 
-            market_row = stock_info.loc[stock_info["code"] == code]
 
-            market = market_row.iloc[0]["market"] if not market_row.empty else "KOSPI"
 
-            buy_th = params.buy_kospi if "KOSPI" in market else params.buy_kosdaq
 
-
 
-            # entry
 
-            if today["disparity"] <= buy_th and code not in positions and len(positions) < params.max_positions:
 
-                open_price = float(next_row["open"])
 
-                if open_price <= 0:
 
+        d = dates[i]
 
+        nd = dates[i + 1]
 
+
 
+        # --- 1) 기존 포지션 청산 판단 (t일 기준 -> t+1 시가 청산) ---
 
+        for code in list(positions.keys()):
 
+            today = get_row(code, d)
 
+            next_row = get_row(code, nd)
 
+            if today is None or next_row is None:
 
+                continue
 
+
 
+            pos = positions[code]
 
+            pos["hold_days"] += 1
 
+            exit_price = float(next_row["open"])
 
+            if pos["avg_price"] <= 0 or exit_price <= 0:
 
+                continue
 
+
 
+            ret = (exit_price / pos["avg_price"]) - 1
 
+            should_sell = False
 
+            if float(today["disparity"]) >= params.sell_disparity:
 
+                should_sell = True
 
+            if ret <= params.stop_loss:
 
+                should_sell = True
 
+            if pos["hold_days"] >= params.max_holding_days:
 
+                should_sell = True
 
+
 
+            if should_sell:
 
+                proceeds = pos["qty"] * exit_price
 
+                cash += proceeds
 
+                trades.append({
 
+                    "code": code,
 
+                    "entry_date": pos["entry_date"].strftime("%Y-%m-%d"),
 
+                    "entry_price": pos["avg_price"],
 
+                    "exit_date": nd.strftime("%Y-%m-%d"),
 
+                    "exit_price": exit_price,
 
+                    "qty": pos["qty"],
 
+                    "pnl": proceeds - (pos["qty"] * pos["avg_price"]),
 
+                    "ret": ret,
 
+                    "hold_days": pos["hold_days"],
 
+                })
 
+                del positions[code]
 
+
 
+        # --- 2) 종목 선별(신호) 및 신규 진입 (t일 기준 -> t+1 시가 진입) ---
 
+        day_df = prices.loc[prices["date"] == d].copy()
 
+        next_df = prices.loc[prices["date"] == nd][["code", "open", "close"]].copy()
 
+        if day_df.empty or next_df.empty:
 
+            continue
 
+
 
+        # 유동성 필터(당일 기준) + 상위 N개
 
+        day_df = day_df.sort_values("amount", ascending=False)
 
+        day_df = day_df[day_df["amount"] >= params.min_amount].head(params.liquidity_rank)
 
+
 
+        # 당일 선별된 종목(실제 generate_signals와 동일하게 amount 순서대로, max_positions 캡 적용)
 
+        signals_final: List[str] = []
 
+        signals_all: List[str] = []
 
+
 
+        for _, row in day_df.iterrows():
 
+            code = row["code"]
 
+            th = buy_threshold(code)
 
+
 
+            # trend filter: ma25 상승
 
+            if params.trend_ma25_rising:
 
+                ma25 = float(row.get("ma25", 0) or 0)
 
+                ma25_prev = row.get("ma25_prev")
 
+                if ma25_prev is None or pd.isna(ma25_prev):
 
                     continue
 
-                qty = int(cash // (params.max_positions * open_price))
 
-                if qty > 0:
 
-                    cost = qty * open_price
 
-                    cash -= cost
 
-                    positions[code] = {
 
-                        "qty": qty,
 
-                        "avg_price": open_price,
 
-                        "entry_date": next_dt.date(),
 
-                        "hold_days": 0,
 
-                    }
 
-                    trade_log.append({
 
-                        "date": next_dt.date(),
 
-                        "code": code,
 
-                        "action": "BUY",
 
-                        "price": open_price,
 
-                        "qty": qty,
 
-                        "cash": cash,
 
-                    })
 
-
 
-            # exit
 
+                if ma25 <= float(ma25_prev):
 
+                    continue
 
+
 
+            if float(row["disparity"]) <= th:
 
+                signals_all.append(code)
 
+                if len(signals_final) < params.max_positions:
 
+                    signals_final.append(code)
 
+
 
+        # selection report: 익일 시가->종가 기준(기본)
 
+        merged_next = next_df.set_index("code")
 
+        for code in signals_final:
 
+            if code not in merged_next.index:
 
+                continue
 
+            op = float(merged_next.loc[code, "open"])
 
+            cl = float(merged_next.loc[code, "close"])
 
+            if op <= 0:
 
+                continue
 
+            r = (cl / op) - 1
 
+            selection_rows.append({
 
+                "signal_date": d.strftime("%Y-%m-%d"),
 
+                "code": code,
 
+                "next_open": op,
 
+                "next_close": cl,
 
+                "next_intraday_ret": r,
 
+                "win": int(r > 0),
 
+                "signals_all_count": len(signals_all),
 
+                "signals_final_count": len(signals_final),
 
+            })
 
+
 
+        # 실제 진입 (max_positions까지, 현금 배분: 동일 로직 유지)
 
+        for code in signals_final:
 
             if code in positions:
 
-                pos = positions[code]
 
-                pos["hold_days"] += 1
 
-                exit_price = float(next_row["open"])
 
-                if pos["avg_price"] <= 0 or exit_price <= 0:
 
-                    continue
 
-                ret = (exit_price / pos["avg_price"]) - 1
 
-                should_sell = False
 
-                if today["disparity"] >= params.sell_disparity:
 
-                    should_sell = True
 
-                if ret <= params.stop_loss:
 
-                    should_sell = True
 
-                if pos["hold_days"] >= params.max_holding_days:
 
-                    should_sell = True
 
-                if should_sell:
 
-                    cash += pos["qty"] * exit_price
 
-                    trade_log.append({
 
-                        "date": next_dt.date(),
 
-                        "code": code,
 
-                        "action": "SELL",
 
-                        "price": exit_price,
 
-                        "qty": pos["qty"],
 
-                        "cash": cash,
 
-                    })
 
-                    del positions[code]
 
-
 
+                continue
 
+            if len(positions) >= params.max_positions:
 
+                break
 
+
 
+            today = get_row(code, d)
 
+            next_row = get_row(code, nd)
 
+            if today is None or next_row is None:
 
+                continue
 
+
 
+            open_price = float(next_row["open"])
 
+            if open_price <= 0:
 
+                continue
 
+
 
+            qty = int(cash // (params.max_positions * open_price))
 
+            if qty <= 0:
 
+                continue
 
+            cost = qty * open_price
 
+            cash -= cost
 
+            positions[code] = {
 
+                "qty": qty,
 
+                "avg_price": open_price,
 
+                "entry_date": nd,
 
+                "hold_days": 0,
 
+            }
 
+
 
+        # --- 3) 일별 평가액 기록 (t+1일 시가 기준 보유 포지션 평가) ---
 
+        # (보유 종목은 nd 시가로 평가)
 
         equity = cash
 
         for code, pos in positions.items():
 
-            dfc = grouped[code]
 
-            row_today = dfc[dfc["date"] == today_dt]
 
-            if row_today.empty:
 
-                continue
 
-            close_price = row_today.iloc[0]["close"]
 
-            equity += pos["qty"] * close_price
 
-        equity_curve.append({"date": today_date, "equity": equity})
 
-
 
+            nrow = get_row(code, nd)
 
+            if nrow is None:
 
+                continue
 
+            px = float(nrow["open"])
 
+            equity += pos["qty"] * px
 
+
 
+        equity_curve.append({"date": nd.strftime("%Y-%m-%d"), "equity": equity, "cash": cash, "positions": len(positions)})
 
+
 
+    # 결과 저장
 
+    output_dir.mkdir(parents=True, exist_ok=True)
 
     equity_df = pd.DataFrame(equity_curve)
 
-    trades_df = pd.DataFrame(trade_log)
 
-    output_dir.mkdir(parents=True, exist_ok=True)
 
     equity_df.to_csv(output_dir / "equity_curve.csv", index=False)
 
+
 
+    trades_df = pd.DataFrame(trades)
 
     trades_df.to_csv(output_dir / "trade_log.csv", index=False)
 
-    print(f"saved {len(trades_df)} trades, equity_curve {len(equity_df)} rows")
 
+
 
+    selection_df = pd.DataFrame(selection_rows)
 
+    selection_df.to_csv(output_dir / "selection_report.csv", index=False)
 
+
 
+    # 요약 출력
 
+    trade_win_rate = float((trades_df["pnl"] > 0).mean()) if len(trades_df) else 0.0
 
+    sel_win_rate = float(selection_df["win"].mean()) if len(selection_df) else 0.0
 
+    print(f"saved trades={len(trades_df)}, selection_rows={len(selection_df)}, equity_rows={len(equity_df)}")
 
+    print(f"trade_win_rate={trade_win_rate:.2%}, selection_win_rate(next_intraday)={sel_win_rate:.2%}")
 
+
 
 
 
 
 
 def main():
 
     parser = argparse.ArgumentParser()
 
+    parser.add_argument("--output-dir", default="data", help="output directory for reports")
 
     args = parser.parse_args()
 
     settings = load_settings()
 
     params = load_strategy(settings)
 
     store = SQLiteStore(settings.get("database", {}).get("path", "data/market_data.db"))
 
-    run_backtest(store, params)
 
+    run_backtest(store, params, output_dir=Path(args.output_dir))
 
 
 
 
 
 if __name__ == "__main__":
 
--- a/src/trader.py
+++ b/src/trader.py
@@ -39,8 +39,11 @@
     if prices.empty:
 
         logging.error("daily_price가 비어있습니다. daily_loader를 먼저 실행하세요.")
 
         return []
 
-    # latest row per code
 
-    latest = prices.sort_values("date").groupby("code").tail(1)
 
+    # latest row per code (+ ma25_prev for trend filter)
 
+    prices = prices.sort_values("date")
 
+    last2 = prices.groupby("code").tail(2).copy()
 
+    last2["ma25_prev"] = last2.groupby("code")["ma25"].shift(1)
 
+    latest = last2.groupby("code").tail(1)
 
     stock_info = store.conn.execute("SELECT code,name,market,marcap FROM stock_info").fetchall()
 
     stock_df = {row[0]: {"name": row[1], "market": row[2], "marcap": row[3]} for row in stock_info}
 
     # liquidity filter
 
@@ -58,6 +61,16 @@
             break
 
         market = stock_df.get(row["code"], {}).get("market", "KOSPI")
 
         buy_th = params.buy_kospi if "KOSPI" in market else params.buy_kosdaq
 
+        # trend filter (optional)
 
+        if getattr(params, "trend_ma25_rising", False):
 
+            ma25_prev = row.get("ma25_prev")
 
+            if ma25_prev is None:
 
+                continue
 
+            try:
 
+                if float(row.get("ma25") or 0) <= float(ma25_prev):
 
+                    continue
 
+            except Exception:
 
+                continue
 
         if row["disparity"] <= buy_th:
 
             qty = int(budget_per_pos // row["close"])
 
             if qty <= 0:
 
--- a/config/strategy.yaml
+++ b/config/strategy.yaml
@@ -1,11 +1,15 @@
 liquidity_rank: 300
 
-min_amount: 50000000000
 
+min_amount: 1000000000
 
 buy:
 
   kospi_disparity: -0.05
 
-  kosdaq_disparity: -0.10
 
+  kosdaq_disparity: -0.20
 
+  trend_filter:
 
+    ma25_rising: true
 
 sell:
 
-  take_profit_disparity: -0.01
 
-  stop_loss: -0.05
 
-  max_holding_days: 3
 
+  take_profit_disparity: 0.0
 
+  stop_loss: -0.30
 
+  max_holding_days: 15
 
 position:
 
   max_positions: 10
 
+report:
 
+  selection_horizon_days: 1
 
--- a/config/settings.yaml
+++ b/config/settings.yaml
@@ -8,6 +8,8 @@
   ws_url_paper: "ws://ops.koreainvestment.com:31000"
 
   app_key: "${KIS_APP_KEY}"
 
   app_secret: "${KIS_APP_SECRET}"
 
+  use_hashkey: true
 
+  hashkey_cache_ttl_sec: 30
 
   account_no: "${KIS_ACCOUNT_NO}"  # 예: 00000000-01
 
   custtype: "P"
 
   token_cache_path: ".cache/kis_token.json"
 
--- a/config/strategy_default.yaml
+++ b/config/strategy_default.yaml
@@ -0,0 +1,11 @@
+liquidity_rank: 300
 
+min_amount: 50000000000
 
+buy:
 
+  kospi_disparity: -0.05
 
+  kosdaq_disparity: -0.10
 
+sell:
 
+  take_profit_disparity: -0.01
 
+  stop_loss: -0.05
 
+  max_holding_days: 3
 
+position:
 
+  max_positions: 10
 
